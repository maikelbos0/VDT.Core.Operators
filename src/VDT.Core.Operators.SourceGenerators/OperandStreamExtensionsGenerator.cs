using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;

namespace VDT.Core.Operators.SourceGenerators;

[Generator]
public class OperandStreamExtensionsGenerator : IIncrementalGenerator {
    public void Initialize(IncrementalGeneratorInitializationContext context) {
        var ops = context.SyntaxProvider.CreateSyntaxProvider(
            static (n, _) => n is ClassDeclarationSyntax,
            static (n, _) => (INamedTypeSymbol)n.SemanticModel.GetDeclaredSymbol(n.Node)!
        ).Where(c => c.AllInterfaces.Any(i => i.Name == "IOperator"));


        context.RegisterSourceOutput(ops, (sourceContext, op) => {
            var className = $"{op.Name}OperandStreamExtensions";

            sourceContext.AddSource($"{className}.g.cs", $@"// <auto-generated/>

using VDT.Core.Operators;

public static class {className} {{
{string.Join("", op.Constructors.Select(constructor => CreateMethod(op, constructor)))}
}}
");
        });
    }

    private static string CreateMethod(INamedTypeSymbol op, IMethodSymbol constructor) {
        var targetStreamType = ((IMethodSymbol)op.GetMembers("Execute").Single()).Parameters.Single(param => param.Name == "targetStream").Type;
        var targetStreamValueType = ((INamedTypeSymbol)targetStreamType).TypeArguments.Single();

        var methodParameters = new List<string>() { "this IOperandStream<TValue> operandStream" };
        methodParameters.AddRange(constructor.Parameters.Select(param => $"{param.Type} {param.Name}"));

        return $@"
//    public static IOperandStream<{targetStreamValueType}> {op.Name}<{string.Join(", ", op.TypeArguments)}>({string.Join(", ", methodParameters)})
//        => operandStream.Pipe(new {op.Name}<{string.Join(", ", op.TypeArguments)}>({string.Join("", constructor.Parameters.Select(param => param.Name))}));
";
    }
}
